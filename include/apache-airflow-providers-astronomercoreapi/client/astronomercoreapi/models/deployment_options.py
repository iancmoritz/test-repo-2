# coding: utf-8

"""
    Astro Core API

    Astro Core API  # noqa: E501

    The version of the OpenAPI document: v1alpha1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List
from pydantic import BaseModel, Field, StrictStr, conlist
from astronomercoreapi.models.resource_quota_options import ResourceQuotaOptions
from astronomercoreapi.models.runtime_release import RuntimeRelease
from astronomercoreapi.models.scheduler_machine import SchedulerMachine
from astronomercoreapi.models.worker_machine import WorkerMachine
from astronomercoreapi.models.worker_queue_options import WorkerQueueOptions

class DeploymentOptions(BaseModel):
    """
    DeploymentOptions
    """
    executors: conlist(StrictStr) = Field(...)
    resource_quotas: ResourceQuotaOptions = Field(..., alias="resourceQuotas")
    runtime_releases: conlist(RuntimeRelease) = Field(..., alias="runtimeReleases")
    scheduler_machines: conlist(SchedulerMachine) = Field(..., alias="schedulerMachines")
    worker_machines: conlist(WorkerMachine) = Field(..., alias="workerMachines")
    worker_queues: WorkerQueueOptions = Field(..., alias="workerQueues")
    __properties = ["executors", "resourceQuotas", "runtimeReleases", "schedulerMachines", "workerMachines", "workerQueues"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> DeploymentOptions:
        """Create an instance of DeploymentOptions from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of resource_quotas
        if self.resource_quotas:
            _dict['resourceQuotas'] = self.resource_quotas.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in runtime_releases (list)
        _items = []
        if self.runtime_releases:
            for _item in self.runtime_releases:
                if _item:
                    _items.append(_item.to_dict())
            _dict['runtimeReleases'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in scheduler_machines (list)
        _items = []
        if self.scheduler_machines:
            for _item in self.scheduler_machines:
                if _item:
                    _items.append(_item.to_dict())
            _dict['schedulerMachines'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in worker_machines (list)
        _items = []
        if self.worker_machines:
            for _item in self.worker_machines:
                if _item:
                    _items.append(_item.to_dict())
            _dict['workerMachines'] = _items
        # override the default output from pydantic by calling `to_dict()` of worker_queues
        if self.worker_queues:
            _dict['workerQueues'] = self.worker_queues.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> DeploymentOptions:
        """Create an instance of DeploymentOptions from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return DeploymentOptions.parse_obj(obj)

        _obj = DeploymentOptions.parse_obj({
            "executors": obj.get("executors"),
            "resource_quotas": ResourceQuotaOptions.from_dict(obj.get("resourceQuotas")) if obj.get("resourceQuotas") is not None else None,
            "runtime_releases": [RuntimeRelease.from_dict(_item) for _item in obj.get("runtimeReleases")] if obj.get("runtimeReleases") is not None else None,
            "scheduler_machines": [SchedulerMachine.from_dict(_item) for _item in obj.get("schedulerMachines")] if obj.get("schedulerMachines") is not None else None,
            "worker_machines": [WorkerMachine.from_dict(_item) for _item in obj.get("workerMachines")] if obj.get("workerMachines") is not None else None,
            "worker_queues": WorkerQueueOptions.from_dict(obj.get("workerQueues")) if obj.get("workerQueues") is not None else None
        })
        return _obj

