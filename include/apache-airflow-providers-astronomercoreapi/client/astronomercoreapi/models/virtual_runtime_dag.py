# coding: utf-8

"""
    Astro Core API

    Astro Core API  # noqa: E501

    The version of the OpenAPI document: v1alpha1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, Dict, List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
from astronomercoreapi.models.dag_tag import DagTag

class VirtualRuntimeDag(BaseModel):
    """
    VirtualRuntimeDag
    """
    dag_id: StrictStr = Field(..., alias="dagId")
    default_view: Optional[StrictStr] = Field(None, alias="defaultView")
    description: Optional[StrictStr] = None
    file_token: StrictStr = Field(..., alias="fileToken")
    fileloc: StrictStr = Field(...)
    has_import_errors: Optional[StrictBool] = Field(None, alias="hasImportErrors")
    has_task_concurrency_limits: Optional[StrictBool] = Field(None, alias="hasTaskConcurrencyLimits")
    is_active: Optional[StrictBool] = Field(None, alias="isActive")
    is_paused: Optional[StrictBool] = Field(None, alias="isPaused")
    is_subdag: Optional[StrictBool] = Field(None, alias="isSubdag")
    last_expired: Optional[StrictStr] = Field(None, alias="lastExpired")
    last_parsed_time: Optional[StrictStr] = Field(None, alias="lastParsedTime")
    last_pickled: Optional[StrictStr] = Field(None, alias="lastPickled")
    max_active_runs: Optional[StrictInt] = Field(None, alias="maxActiveRuns")
    max_active_tasks: Optional[StrictInt] = Field(None, alias="maxActiveTasks")
    next_dagrun: Optional[StrictStr] = Field(None, alias="nextDagrun")
    next_dagrun_create_after: Optional[StrictStr] = Field(None, alias="nextDagrunCreateAfter")
    next_dagrun_data_interval_end: Optional[StrictStr] = Field(None, alias="nextDagrunDataIntervalEnd")
    next_dagrun_data_interval_start: Optional[StrictStr] = Field(None, alias="nextDagrunDataIntervalStart")
    owners: conlist(StrictStr) = Field(...)
    pickle_id: Optional[StrictStr] = Field(None, alias="pickleId")
    root_dag_id: Optional[StrictStr] = Field(None, alias="rootDagId")
    schedule_interval: Optional[Dict[str, Any]] = Field(None, alias="scheduleInterval")
    scheduler_lock: Optional[StrictBool] = Field(None, alias="schedulerLock")
    tags: Optional[conlist(DagTag)] = None
    timetable_description: Optional[StrictStr] = Field(None, alias="timetableDescription")
    __properties = ["dagId", "defaultView", "description", "fileToken", "fileloc", "hasImportErrors", "hasTaskConcurrencyLimits", "isActive", "isPaused", "isSubdag", "lastExpired", "lastParsedTime", "lastPickled", "maxActiveRuns", "maxActiveTasks", "nextDagrun", "nextDagrunCreateAfter", "nextDagrunDataIntervalEnd", "nextDagrunDataIntervalStart", "owners", "pickleId", "rootDagId", "scheduleInterval", "schedulerLock", "tags", "timetableDescription"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> VirtualRuntimeDag:
        """Create an instance of VirtualRuntimeDag from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in tags (list)
        _items = []
        if self.tags:
            for _item in self.tags:
                if _item:
                    _items.append(_item.to_dict())
            _dict['tags'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> VirtualRuntimeDag:
        """Create an instance of VirtualRuntimeDag from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return VirtualRuntimeDag.parse_obj(obj)

        _obj = VirtualRuntimeDag.parse_obj({
            "dag_id": obj.get("dagId"),
            "default_view": obj.get("defaultView"),
            "description": obj.get("description"),
            "file_token": obj.get("fileToken"),
            "fileloc": obj.get("fileloc"),
            "has_import_errors": obj.get("hasImportErrors"),
            "has_task_concurrency_limits": obj.get("hasTaskConcurrencyLimits"),
            "is_active": obj.get("isActive"),
            "is_paused": obj.get("isPaused"),
            "is_subdag": obj.get("isSubdag"),
            "last_expired": obj.get("lastExpired"),
            "last_parsed_time": obj.get("lastParsedTime"),
            "last_pickled": obj.get("lastPickled"),
            "max_active_runs": obj.get("maxActiveRuns"),
            "max_active_tasks": obj.get("maxActiveTasks"),
            "next_dagrun": obj.get("nextDagrun"),
            "next_dagrun_create_after": obj.get("nextDagrunCreateAfter"),
            "next_dagrun_data_interval_end": obj.get("nextDagrunDataIntervalEnd"),
            "next_dagrun_data_interval_start": obj.get("nextDagrunDataIntervalStart"),
            "owners": obj.get("owners"),
            "pickle_id": obj.get("pickleId"),
            "root_dag_id": obj.get("rootDagId"),
            "schedule_interval": obj.get("scheduleInterval"),
            "scheduler_lock": obj.get("schedulerLock"),
            "tags": [DagTag.from_dict(_item) for _item in obj.get("tags")] if obj.get("tags") is not None else None,
            "timetable_description": obj.get("timetableDescription")
        })
        return _obj

